---
title: Redis 缓存：数据一致性
date: 2024-06-04 10:00:00 +0800
categories: [Redis]
tags: [redis] 
description: 为什么需要使用缓存？
comments: true
---

# Redis 缓存：数据一致性

## 1. 为什么需要使用缓存？

缓存是一种常用的技术，用于提高数据检索速度，从而优化系统的整体性能和效率。以下是使用缓存的几个主要原因：

1. **提高响应速度**：缓存可以将经常访问的数据存储在快速访问的存储系统中（如内存），这比从慢速存储（如硬盘或远程数据库）中检索数据要快得多。这意味着应用程序可以更快地响应用户请求。

2. **减少数据库负载**：通过在缓存中存储频繁查询的结果，可以减少对后端数据库的访问次数。这不仅可以减少数据库的工作负载，还可以避免在高流量情况下数据库成为瓶颈。

3. **节省成本**：减少对数据库的查询可以降低数据库服务器的规模需求，从而减少维护成本。此外，由于缓存通常使用更少的资源（如CPU和RAM），因此它可以更加经济高效。

4. **提高可伸缩性**：缓存可以帮助应对突发的流量增加，例如在促销或特殊事件期间。通过缓存常见的请求结果，系统可以处理更多的并发用户，而不会降低性能。

5. **减少网络延迟**：在分布式系统中，数据可能需要从远程服务器检索，这可能涉及显著的网络延迟。通过将数据缓存更靠近用户（例如，在用户的本地设备或地理上接近用户的服务器上），可以显著减少数据检索时间。

尽管缓存带来了许多优势，但它也引入了一些复杂性，如缓存一致性、缓存失效策略和内存管理等。因此，设计和维护缓存系统需要仔细考虑这些因素，以确保系统的正确性和高效性。

## 2. 为什么要保持数据的一致性？如果不保持数据的一致性会存在什么问题？

解答问题最好方式就举例子通俗易懂，所以接下来我们来通过电商库存的例子来了解下数据一致性的重要性。

![例子](/assets/img/2024-06-03/1.png)

如上面图片我们在 redis 查询的库存数为 4，实际数据库中的库存数为 3。这样就会造成超卖的现象，反之就会发生少买的情况。这就会对买家造成严重的影响，所以说保持数据一致性是重要且必要的

## 3. 缓存的类型

### 3.1 只读缓存

什么是只读缓存？就是在使用缓存的时候只进行读取操作。具体如下图：

![只读缓存](/assets/img/2024-06-03/2.png)

### 3.2 读写缓存

什么是读写缓存? 就是在使用缓存的时候即进行读取操作还会进行写入操作。具体如下图：

![读写缓存](/assets/img/2024-06-03/3.png)

## 4. 使用缓存必须要解决的问题

- **缓存穿透**：当一个请求查询的数据在缓存中不存在，且在数据库中也不存在时，如果每次都直接查询数据库，就会导致缓存无法起到应有的作用，从而影响性能。

- **缓存击穿**：当一个热点数据在缓存中的过期时间到了，而此时有大量请求同时访问该数据，这些请求会直接穿透缓存访问数据库，导致数据库压力瞬间增大。

- **缓存雪崩**：当缓存中大量的数据同时过期，导致大量请求直接访问数据库，可能会导致数据库压力过大，甚至宕机。

### 4.2.1 如何避免缓存穿透

1. **缓存空结果**：
   
   - 对于查询结果为空的数据，可以将空结果（如空字符串或特定标志）也缓存起来，并设置较短的过期时间。这样下次查询相同的数据时，直接返回缓存中的空结果，避免每次都查询数据库。

2. **使用布隆过滤器**：
   
   - 在查询缓存之前，使用布隆过滤器（Bloom Filter）来判断数据是否存在。如果布隆过滤器判断数据不存在，则直接返回空结果，避免查询数据库。布隆过滤器占用内存较少，能够高效地判断数据的存在性。

3. **参数校验和限制**：
   
   - 对于用户输入的查询参数进行严格校验，过滤掉非法和不合理的请求，防止恶意攻击和无效查询。例如，对 ID 范围、字符串格式等进行校验。

4. **缓存降级**：
   
   - 在缓存失效或数据不存在时，采用降级策略，比如返回默认值或空结果，避免对数据库造成过大压力。

5. **限流和防刷**：
   
   - 对频繁访问相同数据的请求进行限流和防刷处理，防止恶意请求穿透缓存对数据库造成冲击。

### 4.2.2 如何避免缓存击穿

1. **设置热点数据永不过期**：
   
   - 对于一些核心业务的热点数据，可以设置为永不过期，或者在数据更新时主动更新缓存。

2. **使用互斥锁（Mutex Lock）**：
   
   - 当缓存失效时，使用互斥锁来保证只有一个线程去加载数据到缓存中，其他线程等待缓存更新完成后再读取。这样可以避免大量请求同时访问数据库。

3. **使用分布式锁**：
   
   - 在分布式系统中，可以使用分布式锁（如基于 Redis 的分布式锁）来实现互斥锁的功能，确保只有一个服务实例去更新缓存。

4. **异步加载**：
   
   - 当缓存失效时，可以异步地加载数据到缓存中，而不是同步等待。这样可以减少请求的等待时间，提高系统的响应速度。

5. **使用二级缓存**：
   
   - 设置两级缓存，一级缓存失效时，可以使用二级缓存来提供服务，同时更新一级缓存。

6. **缓存预热**：
   
   - 在系统启动或低峰期，提前将热点数据加载到缓存中，以减少高峰期的缓存击穿风险。

### 4.2.3 如何避免缓存雪崩

1. **设置不同的过期时间**：
   - 为缓存数据设置不同的过期时间，避免大量数据在同一时间点失效。可以通过在过期时间上增加一个随机值来实现。

## 5. 读缓存怎么保持数据的一致性

- 为什么会造成读缓存数据不一致
  
  ![image](/assets/img/2024-06-03/4.png)
  
  客户端2更新库存为 4 之后删除缓存失败，这就会导致客户端1获取的数据不是最新的数据从到导致的数据一致性的问题

- 如何解决数据一致性问题
  
  我们首先想到解决方是就是重试，但是一次请求中进行同步重试这样请求的资源有限，很大的概率会造成接口超时等问题。既然同步重试不可能我们是不是可以异步重试解决这个问题
  
  ![image](/assets/img/2024-06-03/5.png)

## 5. 读写缓存怎么保持数据的一致性

## 6. 总结
